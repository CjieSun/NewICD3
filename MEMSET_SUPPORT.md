# memset Support in NewICD3

This document describes the newly added memset support in the NewICD3 segmentation fault handler.

## Overview

The NewICD3 `segv_handler` has been enhanced to support bulk memory operations commonly generated by `memset()` function calls. This enables proper handling of REP STOS* instruction sequences when they target device memory regions.

## Supported Instructions

### REP STOSB (0xF3 0xAA)
- **Purpose**: 8-bit memory fill operations
- **Usage**: `memset(ptr, value, count)` with byte-level granularity
- **Behavior**: Stores AL register value to [RDI], repeats RCX times
- **Example**: Filling a buffer with a specific byte pattern

### REP STOSW (0xF3 0x66 0xAB)  
- **Purpose**: 16-bit memory fill operations
- **Usage**: Word-aligned memory initialization
- **Behavior**: Stores AX register value to [RDI], repeats RCX times
- **Example**: Filling buffer with 16-bit patterns

### REP STOSD (0xF3 0xAB)
- **Purpose**: 32-bit memory fill operations  
- **Usage**: Dword-aligned memory initialization
- **Behavior**: Stores EAX register value to [RDI], repeats RCX times
- **Example**: Efficient filling of large memory regions

### REP STOSQ (0xF3 0x48 0xAB)
- **Purpose**: 64-bit memory fill operations
- **Usage**: Qword-aligned memory initialization (64-bit mode)
- **Behavior**: Stores RAX register value to [RDI], repeats RCX times
- **Example**: High-performance bulk memory operations

## Implementation Details

### Instruction Detection
The segv_handler now detects REP prefixes (0xF2, 0xF3) followed by STOS* opcodes during instruction parsing:

```c
/* Check for REP/REPE/REPNE prefixes (used by memset) */
if (*inst_ptr == 0xF2 || *inst_ptr == 0xF3) {
    has_rep_prefix = 1;
    printf("Detected REP prefix: 0x%02X\n", *inst_ptr);
}
```

### Parameter Extraction
For REP STOS* instructions, the handler extracts:
- **Value**: From AL/AX/EAX/RAX register (depending on operation size)
- **Destination**: From RDI register 
- **Count**: From RCX register

### Bulk Operation Processing
REP operations are converted into individual device model write calls:

```c
/* Perform the bulk write operation as individual writes to device model */
for (uint64_t i = 0; i < rep_count; i++) {
    uintptr_t current_addr = dest_addr + (i * access_size);
    
    /* Send write operation to device model */
    protocol_message_t message = {0};
    message.device_id = devices[j].device_id;
    message.command = CMD_WRITE;
    message.address = (uint32_t)current_addr;
    message.length = access_size;
    memcpy(message.data, &write_data, access_size);
    
    send_message_to_model(&message, &response);
}
```

### Register State Management
After processing REP operations, registers are properly updated:
- **RDI**: Advanced by (count Ã— access_size)
- **RCX**: Set to 0 (operation completed)
- **RIP**: Advanced by instruction length

## Testing

Three comprehensive test cases validate the implementation:

### 1. REP STOSB Test
```c
__asm__ volatile (
    "movq %0, %%rdi\n\t"     /* Destination address */
    "movq %1, %%rcx\n\t"     /* Count */
    "movb %2, %%al\n\t"      /* Pattern to store */
    "rep stosb\n\t"          /* REP STOSB instruction */
    :
    : "r"(dest), "r"(count), "r"(pattern)
    : "rdi", "rcx", "rax", "memory"
);
```

### 2. REP STOSD Test  
```c
__asm__ volatile (
    "movq %0, %%rdi\n\t"     /* Destination address */
    "movq %1, %%rcx\n\t"     /* Count */
    "movl %2, %%eax\n\t"     /* Pattern to store (32-bit) */
    "rep stosl\n\t"          /* REP STOSD instruction */
    :
    : "r"(dest), "r"(count), "r"(pattern)
    : "rdi", "rcx", "rax", "memory"
);
```

### 3. Zero-Fill Test
Validates `memset(ptr, 0, size)` operations commonly used for buffer initialization.

## Usage Examples

### Basic Usage
The enhancement is transparent to existing code. Any `memset()` call targeting device memory regions will now be properly handled:

```c
uint8_t *device_buffer = (uint8_t *)0x40000000;  /* Device memory */
memset(device_buffer, 0xAA, 1024);               /* Now supported! */
```

### Debugging Scenarios
This is particularly useful when debugging drivers that perform bulk memory operations:

```c
/* UART device initialization */
struct uart_regs *uart = (struct uart_regs *)0x40000000;
memset(uart, 0, sizeof(*uart));  /* Zero-initialize device registers */

/* DMA buffer setup */
uint8_t *dma_buffer = (uint8_t *)0x50000000;
memset(dma_buffer, 0xFF, DMA_BUFFER_SIZE);  /* Fill with pattern */
```

## Performance Characteristics

- **Conversion**: REP operations are converted to individual device model writes
- **Protocol**: Each byte/word/dword uses standard device communication protocol
- **Overhead**: Minimal - only processes operations targeting registered device regions
- **Compatibility**: Maintains full backward compatibility with existing individual memory access patterns

## Benefits

1. **Enhanced Debugging**: Supports real-world driver code using memset operations
2. **Transparency**: No code changes required for existing memset usage
3. **Completeness**: Covers all common bulk memory operation patterns
4. **Accuracy**: Maintains exact semantic behavior of REP STOS* instructions
5. **Integration**: Seamless integration with existing device model communication

## Demonstration

Run the included demonstration program:

```bash
make clean && make
./demo_memset
```

This will show REP STOSB, REP STOSD, and zero-fill operations in action, demonstrating proper instruction detection, bulk operation processing, and register state management.